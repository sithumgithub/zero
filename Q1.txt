// Bibliography system using OOP concepts
class Book {
    private int bookID;
    private String title;
    private String author;
    private boolean available;

    // Constructor
    public Book(int bookID, String title, String author) {
        this.bookID = bookID;
        this.title = title;
        this.author = author;
        this.available = true; // Default to available
    }

    // Method to mark the book as borrowed
    public void borrowBook() {
        if (available) {
            available = false;
            System.out.println("Book " + title + " borrowed successfully.");
        } else {
            System.out.println("Book " + title + " is already borrowed.");
        }
    }

    // Method to mark the book as available
    public void returnBook() {
        available = true;
        System.out.println("Book " + title + " returned successfully.");
    }

    // Method to display book details
    public void displayInfo() {
        System.out.println("Book ID: " + bookID);
        System.out.println("Title: " + title);
        System.out.println("Author: " + author);
        System.out.println("Available: " + (available ? "Yes" : "No"));
    }

    // Getter for availability
    public boolean isAvailable() {
        return available;
    }
}

class Member {
    private int memberID;
    private String name;
    private Book borrowedBook;

    // Constructor
    public Member(int memberID, String name) {
        this.memberID = memberID;
        this.name = name;
        this.borrowedBook = null; 
    }

    // Method to borrow a book
    public void borrowBook(Book b) {
        if (borrowedBook != null) {
            System.out.println("Member " + name + " already has a borrowed book.");
        } else if (b.isAvailable()) {
            borrowedBook = b;
            b.borrowBook();
        } else {
            System.out.println("The book " + b.title + " is not available.");
        }
    }

    // Method to return a borrowed book
    public void returnBook() {
        if (borrowedBook != null) {
            borrowedBook.returnBook();
            borrowedBook = null;
        } else {
            System.out.println("No book to return for member " + name + ".");
        }
    }

    // Method to display member details
    public void displayInfo() {
        System.out.println("Member ID: " + memberID);
        System.out.println("Name: " + name);
        if (borrowedBook != null) {
            System.out.println("Borrowed Book: " + borrowedBook.title);
        } else {
            System.out.println("No book borrowed.");
        }
    }
}

public class LibraryManagement {
    public static void main(String[] args) {
        // Create Book objects
        Book book1 = new Book(1, "The Great Gatsby", "F. Scott Fitzgerald");
        Book book2 = new Book(2, "1984", "George Orwell");
        Book book3 = new Book(3, "To Kill a Mockingbird", "Harper Lee");

        // Create Member objects
        Member member1 = new Member(101, "Alice");
        Member member2 = new Member(102, "Bob");

        // Demonstrate borrowing books
        member1.borrowBook(book1); // Alice borrows The Great Gatsby
        member2.borrowBook(book1); // Bob tries to borrow The Great Gatsby (already borrowed)
        member2.borrowBook(book2); // Bob borrows 1984

        // Demonstrate returning books
        member1.returnBook(); // Alice returns her book
        member2.returnBook(); // Bob returns his book

        // Display details of all books
        System.out.println("\nBook Details:");
        book1.displayInfo();
        book2.displayInfo();
        book3.displayInfo();

        // Display details of all members
        System.out.println("\nMember Details:");
        member1.displayInfo();
        member2.displayInfo();
    }
}
-----------------


class PrintAscending {
    public void printNumbers() {
        for (int i = 5; i <= 10; i++) {
            System.out.println(i);
            delay();
        }
    }
}

class PrintDescending {
    public void printNumbers() {
        for (int i = 10; i >= 5; i--) {
            System.out.println(i);
            delay();
        }
    }
}

class PrintLetters {
    public void printLetters() {
        for (char c = 'a'; c <= 'f'; c++) {
            System.out.println(c);
            delay();
        }
    }
}

public class SimpleProgram {
    public static void main(String[] args) {
        new PrintAscending().printNumbers();
        new PrintDescending().printNumbers();
        new PrintLetters().printLetters();
    }

    private static void delay() {
        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

//

class AscendingThread extends Thread {
    @Override
    public void run() {
        for (int i = 5; i <= 10; i++) {
            System.out.println(i);
            delay();
        }
    }
}

class DescendingThread extends Thread {
    @Override
    public void run() {
        for (int i = 10; i >= 5; i--) {
            System.out.println(i);
            delay();
        }
    }
}

class LettersThread extends Thread {
    @Override
    public void run() {
        for (char c = 'a'; c <= 'f'; c++) {
            System.out.println(c);
            delay();
        }
    }
}

public class ThreadedProgram {
    public static void main(String[] args) {
        new AscendingThread().start();
        new DescendingThread().start();
        new LettersThread().start();
    }

    private static void delay() {
        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

// Part (a): Executes sequentiallyâ€”one task completes before the next starts.
// Part (b): Runs tasks concurrently, leading to interleaved output depending on thread scheduling.